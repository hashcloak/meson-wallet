/**
 *Submitted for verification at Etherscan.io on 2020-05-12
*/

// https://tornado.cash Verifier.sol generated by trusted setup ceremony.
/*
* d888888P                                           dP              a88888b.                   dP
*    88                                              88             d8'   `88                   88
*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.
*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88
*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88
*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP
* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
*/
// SPDX-License-Identifier: MIT
// Copyright 2017 Christian Reitwiessner
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// 2019 OKIMS

pragma solidity ^0.7.0;

library Pairing {
  uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

  struct G1Point {
    uint256 X;
    uint256 Y;
  }

  // Encoding of field elements is: X[0] * z + X[1]
  struct G2Point {
    uint256[2] X;
    uint256[2] Y;
  }

  /*
   * @return The negation of p, i.e. p.plus(p.negate()) should be zero.
   */
  function negate(G1Point memory p) internal pure returns (G1Point memory) {
    // The prime q in the base field F_q for G1
    if (p.X == 0 && p.Y == 0) {
      return G1Point(0, 0);
    } else {
      return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));
    }
  }

  /*
   * @return r the sum of two points of G1
   */
  function plus(
    G1Point memory p1,
    G1Point memory p2
  ) internal view returns (G1Point memory r) {
    uint256[4] memory input;
    input[0] = p1.X;
    input[1] = p1.Y;
    input[2] = p2.X;
    input[3] = p2.Y;
    bool success;

    // solium-disable-next-line security/no-inline-assembly
    assembly {
      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)
    // Use "invalid" to make gas estimation work
      switch success case 0 { invalid() }
    }

    require(success, "pairing-add-failed");
  }

  /*
   * @return r the product of a point on G1 and a scalar, i.e.
   *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all
   *         points p.
   */
  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {
    uint256[3] memory input;
    input[0] = p.X;
    input[1] = p.Y;
    input[2] = s;
    bool success;
    // solium-disable-next-line security/no-inline-assembly
    assembly {
      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)
    // Use "invalid" to make gas estimation work
      switch success case 0 { invalid() }
    }
    require(success, "pairing-mul-failed");
  }

  /* @return The result of computing the pairing check
   *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1
   *         For example,
   *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.
   */
  function pairing(
    G1Point memory a1,
    G2Point memory a2,
    G1Point memory b1,
    G2Point memory b2,
    G1Point memory c1,
    G2Point memory c2,
    G1Point memory d1,
    G2Point memory d2
  ) internal view returns (bool) {
    G1Point[4] memory p1 = [a1, b1, c1, d1];
    G2Point[4] memory p2 = [a2, b2, c2, d2];

    uint256 inputSize = 24;
    uint256[] memory input = new uint256[](inputSize);

    for (uint256 i = 0; i < 4; i++) {
      uint256 j = i * 6;
      input[j + 0] = p1[i].X;
      input[j + 1] = p1[i].Y;
      input[j + 2] = p2[i].X[0];
      input[j + 3] = p2[i].X[1];
      input[j + 4] = p2[i].Y[0];
      input[j + 5] = p2[i].Y[1];
    }

    uint256[1] memory out;
    bool success;

    // solium-disable-next-line security/no-inline-assembly
    assembly {
      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)
    // Use "invalid" to make gas estimation work
      switch success case 0 { invalid() }
    }

    require(success, "pairing-opcode-failed");

    return out[0] != 0;
  }
}

contract Verifier {
  uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
  uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
  using Pairing for *;

  struct VerifyingKey {
    Pairing.G1Point alfa1;
    Pairing.G2Point beta2;
    Pairing.G2Point gamma2;
    Pairing.G2Point delta2;
    Pairing.G1Point[7] IC;
  }

  struct Proof {
    Pairing.G1Point A;
    Pairing.G2Point B;
    Pairing.G1Point C;
  }

  function verifyingKey() internal pure returns (VerifyingKey memory vk) {
    vk.alfa1 = Pairing.G1Point(uint256(14489010223118400381985604491675151705346100146555522456499409467943943478797), uint256(13531336277390699654005463202359188038017594156226503139840666524603175843520));
    vk.beta2 = Pairing.G2Point([uint256(14605527091563295461443001225932090015432050108331191340430039125848493953118), uint256(12499959732296138275414677874045819739162372982028848370404875919645474848309)], [uint256(1351489043409872969851574724197477186004173372414532266031081932785192613005), uint256(18812668251996526231218702414717310160773749288670947897732998646185873283568)]);
    vk.gamma2 = Pairing.G2Point([uint256(6269167326145387756917348712727542120312981931843676096311594273548199303246), uint256(8672934304616180527189318283709055507679481408228260671731039319882085607199)], [uint256(11200918146180713118981468920699834546999936626906252800752836874279910438144), uint256(17489687646840054707268829604766931306162115299380407338389302843492182531834)]);
    vk.delta2 = Pairing.G2Point([uint256(20430200049531705600669526040511630259555086973661478934778615068404398956672), uint256(5045674838698586430903552708911426289625578113909043930216419870906472588866)], [uint256(4815527750685951062516479954203910093812242871048752271556893393280298184974), uint256(13217047348031963545299146543518583400793064548137091852588029114737929057518)]);
    vk.IC[0] = Pairing.G1Point(uint256(11304203302271740588179617704933619707017960264160435927360232298535113837469), uint256(710248192817373073383143043231836150005715035189910978092510952558243058109));
    vk.IC[1] = Pairing.G1Point(uint256(13955863408980374619203188790929666730271305492570057030198655780353708336409), uint256(21082205670684153745971246392991219053292228434671663964714506958464290998768));
    vk.IC[2] = Pairing.G1Point(uint256(15297937515379778476267675072544644943062175110954547553211891338564323186069), uint256(19605807919110594315905937164024464476643819088712959312693475962153131427465));
    vk.IC[3] = Pairing.G1Point(uint256(9169595283444530932627040894276243725545956984438349561449291426298887339118), uint256(10229801053966091126447571687952412729724670246668213407412570391798337594295));
    vk.IC[4] = Pairing.G1Point(uint256(15655649156812611438750269326033726526284467230944159809037610161991841725025), uint256(3162530361701624222600096451403096778721606024876502895383505082527740506052));
    vk.IC[5] = Pairing.G1Point(uint256(3154583966593844435825404175345700581164106514975394471003922075182951096268), uint256(16242046074985407440056000699370321086726502495814382065378277056346996130272));
    vk.IC[6] = Pairing.G1Point(uint256(16552355733186447726819722712446040247595319477731713627975442811561212720569), uint256(5663856130895977249049324068862774158147377737177630121909293545897175706922));

  }

  /*
   * @returns Whether the proof is valid given the hardcoded verifying key
   *          above and the public inputs
   */
  function verifyProof(
    bytes memory proof,
    uint256[6] memory input
  ) public view returns (bool) {
    uint256[8] memory p = abi.decode(proof, (uint256[8]));

    // Make sure that each element in the proof is less than the prime q
    for (uint8 i = 0; i < p.length; i++) {
      require(p[i] < PRIME_Q, "verifier-proof-element-gte-prime-q");
    }

    Proof memory _proof;
    _proof.A = Pairing.G1Point(p[0], p[1]);
    _proof.B = Pairing.G2Point([p[2], p[3]], [p[4], p[5]]);
    _proof.C = Pairing.G1Point(p[6], p[7]);

    VerifyingKey memory vk = verifyingKey();

    // Compute the linear combination vk_x
    Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);
    vk_x = Pairing.plus(vk_x, vk.IC[0]);

    // Make sure that every input is less than the snark scalar field
    for (uint256 i = 0; i < input.length; i++) {
      require(input[i] < SNARK_SCALAR_FIELD, "verifier-gte-snark-scalar-field");
      vk_x = Pairing.plus(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));
    }

    return Pairing.pairing(
      Pairing.negate(_proof.A),
      _proof.B,
      vk.alfa1,
      vk.beta2,
      vk_x,
      vk.gamma2,
      _proof.C,
      vk.delta2
    );
  }
}